\section{概述}
在此次实验中，我们用一个大文件模拟磁盘，实现了一个简化的ext文件系统及类Linux命令行界面，支持基本的文件系统命令。为了使我们的文件系统更加完善，更接近于真实的文件系统，我们在基础要求上进行了扩展。我们的文件系统支持以页为单位读写文件，页的大小即为实验说明中提到的块大小4KB，同时我们还实现了一个缓存管理器，程序运行中直接访问到的数据是缓存中的数据。更加具体的内容会在稍后说明。

\section{实验中涉及的类与文件说明}
\begin{center}
	\tcaption{实验中涉及的类与文件说明}
    \begin{longtable}{p{0.4\columnwidth}p{0.6\columnwidth}}
        \toprule
        类/文件 & 含义 \\
        \midrule
        FileManager & 实现创建文件，打开/关闭文件，读取/更新文件中的某一页等底层的文件操作\tabularnewline\tabularnewline
        BufManager & 实现缓存管理器，存储临时访问过的数据并对写入的数据进行暂时存放\tabularnewline\tabularnewline
        LinkList & 双向链表，链表节点代表缓存中页的下标，基于此实现了LRU替换算法\tabularnewline\tabularnewline
        FindPlace & 对LinkList的比较友好的封装\tabularnewline\tabularnewline
        main.cpp & 实现了程序运行时的主逻辑\tabularnewline
        \bottomrule
    \end{longtable}
\end{center}

\begin{center}
    \includegraphics[width=13cm]{uml.png}
    \fcaption{UML类图}
\end{center}

\section{拓展功能}

\subsection{读写文件}
文件读写操作是由底层的FileManager类实现的，它并不是将整个磁盘文件一起读入，而是根据传入的文件中的页索引pageID，移动文件指针到相应的位置，然后读取目标页的内容；文件的写操作与此类似。

\subsection{缓存管理}
本次实验中我们设置的缓存大小为1024页，即约为文件总页数的1/4。除了这些缓存页，BufManager还维护着缓存页与文件中实际的页的对应关系。

程序启动时，缓存会对文件进行预读取。读取文件中的某一页时，程序会首先检查该页是否在缓存中，若在，则直接读取缓存页中的相应信息；若不在，则会首先在缓存中为该页申请分配空间，将该页读入缓存中，再返回缓存页的地址。若要修改文件中的某一页，我们采取了写回(write back)策略，即直接对缓存中的内容进行修改，同时标记该缓存页为“脏页”（即被修改过），当该页被从缓存中替换出去时，才由缓存管理器BufManager完成向实际文件的写入操作。

对于缓存页的置换，我们实现了LRU算法。LinkList中的每一个节点对应了缓存中页的下标，下一次将被置换的缓存页即为LinkList的首元素。若某一缓存页被访问过，则会将其对应的链表节点移动到LinkList的末尾，以此实现了最近未被使用的缓存页会被优先置换。LinkList的操作均是针对缓存而言的，而与缓存中的内容究竟对应于实际文件中的哪一页无关。当某一缓存页被置换时，如果其被标记为“脏页”，则BufManager会将缓存页的内容写入到文件中。在实现“rm”及“rmdir”等命令时，对于被删除的内容，仅仅将其从缓存中移除即可。缓存的更新和维护都是由BufManager在底层实现的，上层只需要调用getPage()接口函数即可。更为详细的内容可以参看源代码。

\section{实现细节}
对于文件系统的各基本命令，我们没有采用逐条命令分别实现的方式，而是先对命令的目标路径进行处理，逐层深入到目标路径的底层目录或文件，并在这期间进行路径合法性的检查，最后再根据不同的命令实现各自的操作。对程序运行逻辑中的一些细节进行说明如下。

\subsection{绝对路径与相对路径}
程序运行时记录有指向缓存中当前目录块和当前目录块对应的索引节点的指针，程序刚启动时当前目录即为根目录，根目录的目录块和索引节点的标号均为固定值0。对于相对路径与绝对路径，根据路径开头是否为'/'进行判断，若为相对路径，则从当前目录开始查找，若为绝对路径，则从根目录开始查找。

某些时候需要输出当前路径名（“>>”之前显示及“pwd”命令），此时输出的应该是绝对路径。但仅从当前目录块无法得知其绝对路径，对此我们的处理是从当前目录开始向上回溯，沿途记录路径，直至根目录，再将其输出。这样也可以解决输入路径为相对路径时路径名中可能含有若干个‘.’符号的问题。

同时还需要注意的是，在沿着路径不断查找的过程中，缓存中页的信息会不断进行更新，原本的当前目录块的内容可能被置换出去，这时指针所指的内容就不再是当前目录块的信息。对此我们的解决方法是记录当前目录块与当前索引节点在文件中的实际位置，输入下一次命令之前重新获取当前目录块与当前索引节点。这样如果当前目录块的信息不在缓存中，会在缓存中为其分配一页，若已在缓存中存在，则直接返回缓存中的地址，没有产生额外的开销。

\subsection{上级目录与当前目录}
每个目录下均有一个名称为“.”的目录，即为本身；除根目录外，每个目录下均有一个名称为“..”的目录，即为上级目录。在目录块中我们没有存储“.”与“..”字符串，而是存储了实际的当前目录名和上级目录名，其中当前目录在dirs数组的索引值为0，上级目录在dirs数组的索引值为1。

对一个目录块来说，想访问其上级目录很容易，只需要查询dirs数组的索引为1的元素即可，但对于数据块来说，其数据内容和索引节点均没有记录上级目录的信息，这在进行文件删除操作时很不方便，于是我们对索引节点的结构进行了修改，使得其中parent域表示其上级目录对应的索引节点的标号。

\subsection{文件与目录的删除}
执行“rm”命令删除文件时，程序会解除数据块及数据块对应的索引节点的占用，即在超级块的BitMap中将对应位置为0，无需抹除实际的数据，这些数据会在该数据块被重新分配后被覆盖掉。接下来修改文件所在的目录，以及该目录所对应的索引节点的i\_file\_size。最后检查该数据块是否在缓存中，若在缓存中，则取消其“脏页”标记，这样可以避免无必要的对文件的实际写入操作，并将缓存页的下标直接插入到LinkList的开头，这样下一次置换时这一数据块就会被置换出缓存，为文件中的其他页腾出空间。

对“rmdir”采用了递归实现的方法，可以参看main.cpp中的RemoveDir函数。类似地，解除了待删除目录下所有子目录以及文件的占用，并最后修改了待删除目录的上级目录块以及上级目录块对应的索引节点。


\section{团队分工}
丁雨晖实现了包括缓存管理器在内的底层框架，剩余部分的工作量两人平分。